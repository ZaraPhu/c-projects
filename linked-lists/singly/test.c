/*
This file is used to test the SinglyLinkedList implementation. Each of the functions implemented
will have their own testing methods, and will be run sequentially when this program is
executed.
Author: Zara Phukan.
Creation Date: April 4, 2025.
NOTE: some of this code will be AI generated, I will be creating notes on which areas are
AI generated. If it doesn't have an explicit note on generation, it was likely written
by me personally.
*/

/*** Dependencies ***/
#include<stdint.h>
#include<stdio.h>
#include<stdlib.h>
#include"singly-linked.h"

/*** Constants ***/
// for clarity in code
#define PASS true
#define FAIL false

// for Node functions
uint8_t DANGLING_NODE_NUM_TESTS = 6;
uint8_t NEXT_NODE_NUM_TESTS = 6;
uint8_t PREV_NODE_NUM_TESTS = 6;

// for SinglyLinkedList functions
uint8_t IS_EMPTY_NUM_TESTS = 3;
uint8_t SIZE_NUM_TESTS = 3;

/*** Node Unit Tests ***/

/** This documentation was generated by AI
 * @brief Tests the dangling_node function for proper node creation and initialization
 *
 * This function performs six tests on the dangling_node functionality:
 * 1. Verifies that a node created with value 0 correctly stores 0 as its data
 * 2. Verifies that a node created with value 0 has its next pointer set to NULL
 * 3. Verifies that a node created with a maximum positive value correctly stores that value
 * 4. Verifies that a node created with a positive value has its next pointer set to NULL
 * 5. Verifies that a node created with a minimum negative value correctly stores that value
 * 6. Verifies that a node created with a negative value has its next pointer set to NULL
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains DANGLING_NODE_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_dangling_node() {
    // heap allocated array to return test results
    bool* tests_status = (bool *) malloc(sizeof(bool) * DANGLING_NODE_NUM_TESTS);

    // Test 1: 0 is set properly for the Node
    Node* node = dangling_node(0);
    if (node->data == 0) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Test 2: Nodes with 0 as data have null next pointer
    if(node->next == NULL) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }
    free(node);

    // Test 3: positive numbers are set properly for the node
    node = dangling_node(INT64_MAX);
    if (node->data == INT64_MAX) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // Test 4: Nodes with positive data have NULL next pointers
    if (node->next == NULL) {
        tests_status[3] = PASS;
    } else {
        tests_status[3] = FAIL;
    }
    free(node);

    // Test 5: negative numbers are set properly for the node
    // this next test case was AI generated
    node = dangling_node(INT64_MIN);
    if (node->data == INT64_MIN) {
        tests_status[4] = PASS;
    } else {
        tests_status[4] = FAIL;
    }

    // Test 6: Nodes with negative data have NULL next pointers
    if (node->next == NULL) {
        tests_status[5] = PASS;
    } else {
        tests_status[5] = FAIL;
    }
    free(node);
    return tests_status;
}

/** This documentation was generated by AI.
* @brief Tests the next_node function for proper node creation and linking
*
* This function performs six tests on the next_node functionality:
* 1. Verifies that a node created with value 0 correctly stores 0 as its data
* 2. Verifies that the next pointer of the base node points to the newly created node
* 3. Verifies that a node created with a maximum positive value correctly stores that value
* 4. Verifies that the next pointer of the base node points to the newly created node with positive value
* 5. Verifies that a node created with a minimum negative value correctly stores that value
* 6. Verifies that the next pointer of the base node points to the newly created node with negative value
*
* @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
*         status of a test. The array contains NEXT_NODE_NUM_TESTS elements and must be freed by
*         the caller when no longer needed.
*/
bool* test_next_node() {
    // This whole function was AI generated using my work on the dangling_node unit test
    // function as context
    bool* tests_status = (bool *) malloc(sizeof(bool) * NEXT_NODE_NUM_TESTS);

    // Test 1: 0 is set properly for the Node
    Node* base = dangling_node(0);
    Node* node = next_node(0, base);
    if (node->data == 0) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Test 2: Next pointer points to the base node
    if(base->next == node) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }
    free(node);

    // Test 3: positive numbers are set properly for the node
    node = next_node(INT64_MAX, base);
    if (node->data == INT64_MAX) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // Test 4: Next pointer points to the base node
    if (base->next == node) {
        tests_status[3] = PASS;
    } else {
        tests_status[3] = FAIL;
    }
    free(node);

    // Test 5: negative numbers are set properly for the node
    node = next_node(INT64_MIN, base);
    if (node->data == INT64_MIN) {
        tests_status[4] = PASS;
    } else {
        tests_status[4] = FAIL;
    }

    // Test 6: Next pointer points to the base node
    if (base->next == node) {
        tests_status[5] = PASS;
    } else {
        tests_status[5] = FAIL;
    }
    free(node);
    free(base);
    return tests_status;
}

/** This documentation was generated by AI.
* @brief Tests the prev_node function for proper node creation and linking
*
* This function performs six tests on the prev_node functionality:
* 1. Verifies that a node created with value 0 correctly stores 0 as its data
* 2. Verifies that the next pointer of the base node points to the newly created node
* 3. Verifies that a node created with a maximum positive value correctly stores that value
* 4. Verifies that the next pointer of the base node points to the newly created node with positive value
* 5. Verifies that a node created with a minimum negative value correctly stores that value
* 6. Verifies that the next pointer of the base node points to the newly created node with negative value
*
* @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
*         status of a test. The array contains NEXT_NODE_NUM_TESTS elements and must be freed by
*         the caller when no longer needed.
*/
bool* test_prev_node() {
    // This whole function was AI generated using my work on the previous unit test
    // function as context
    bool* tests_status = (bool *) malloc(sizeof(bool) * PREV_NODE_NUM_TESTS);

    // Test 1: 0 is set properly for the Node
    Node* base = dangling_node(0);
    Node* node = prev_node(0, base);
    if (node->data == 0) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Test 2: Next pointer points to the base node
    if(node->next == base) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }
    free(node);

    // Test 3: positive numbers are set properly for the node
    node = prev_node(INT64_MAX, base);
    if (node->data == INT64_MAX) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // Test 4: Next pointer points to the base node
    if (node->next == base) {
        tests_status[3] = PASS;
    } else {
        tests_status[3] = FAIL;
    }
    free(node);

    // Test 5: negative numbers are set properly for the node
    node = prev_node(INT64_MIN, base);
    if (node->data == INT64_MIN) {
        tests_status[4] = PASS;
    } else {
        tests_status[4] = FAIL;
    }

    // Test 6: Next pointer points to the base node
    if (node->next == base) {
        tests_status[5] = PASS;
    } else {
        tests_status[5] = FAIL;
    }
    free(node);
    free(base);
    return tests_status;
}

/*** SinglyLinkedList Unit Tests ***/

/** This documentation was written by AI
 * @brief Tests the is_empty function of the SinglyLinkedList implementation
 *
 * This function performs three tests on the is_empty functionality:
 * 1. Verifies that a newly created linked list is correctly identified as empty
 * 2. Verifies that a linked list with one element is correctly identified as not empty
 * 3. Verifies that a linked list with multiple elements is correctly identified as not empty
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains IS_EMPTY_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_is_empty() {
    // need heap allocated array to return each test fail (0) or pass (1)
    bool* tests_status = (bool *) malloc(sizeof(bool) * IS_EMPTY_NUM_TESTS);
    SinglyLinkedList* list_ptr = (SinglyLinkedList *) malloc(sizeof(SinglyLinkedList));
    // Test 1: a new singly linked list is empty
    if (is_empty(list_ptr)) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }
    // Test 2: a singly linked list with one element is not empty
    append_node(list_ptr, 12);
    if (is_empty(list_ptr)) {
        tests_status[1] = FAIL;
    } else {
        tests_status[1] = PASS;
    }
    // Test 3: a singly linked list with multiple elements is not empty
    // this one was autocompleted by an AI code generation
    append_node(list_ptr, 13);
    append_node(list_ptr, 14);
    if (is_empty(list_ptr)) {
        tests_status[2] = FAIL;
    } else {
        tests_status[2] = PASS;
    }
    free(list_ptr);
    return tests_status;
}

/*** Helper Functions */
/**
 * @brief Displays the results of unit test functions
 *
 * This function processes an array of test results and displays whether tests passed or failed.
 * It can show detailed results for each individual test when verbose mode is enabled,
 * and always displays a summary message indicating overall test success or failure.
 *
 * @param tests_status Pointer to a boolean array containing test results (PASS/FAIL)
 * @param num_tests The number of test results in the array
 * @param verbose If true, displays detailed results for each individual test
 */
void display_test_results(bool* tests_status, int8_t num_tests, bool verbose) {
    bool all_passed = true;
    for (int8_t i = 0; i < num_tests; i++) {
        if (tests_status[i] == PASS) {
            if (verbose) {
                printf("Test %d passed\n", i + 1);
            }
        } else {
            if (verbose) {
                printf("Test %d failed\n", i + 1);
            }
            all_passed = false;
        }
    }
    if (all_passed) {
        printf("All tests passed!\n\n");
    } else {
        printf("Some tests failed!\n\n");
    }
}

/*** Program Starting Point */

int main() {
    bool* tests_status = test_dangling_node();
    printf("Testing dangling_node:\n");
    display_test_results(tests_status, DANGLING_NODE_NUM_TESTS, false);
    
    tests_status = test_next_node();
    printf("Testing next_node:\n");
    display_test_results(tests_status, NEXT_NODE_NUM_TESTS, false);
    
    tests_status = test_prev_node();
    printf("Testing prev_node:\n");
    display_test_results(tests_status, PREV_NODE_NUM_TESTS, false);
    
    tests_status = test_is_empty();
    printf("Testing is_empty:\n");
    display_test_results(tests_status, IS_EMPTY_NUM_TESTS, false);
}
