/*
This file is used to test the SinglyLinkedList implementation. Each of the functions implemented
will have their own testing methods, and will be run sequentially when this program is
executed.
Author: Zara Phukan.
Creation Date: April 4, 2025.
NOTE: some of this code will be AI generated, I will be creating notes on which areas are
AI generated. If it doesn't have an explicit note on generation, it was likely written
by me personally.
*/

/*** Dependencies ***/
#include<stdint.h>
#include<stdio.h>
#include<stdlib.h>
#include"singly-linked.h"

/*** Constants ***/
// for clarity in code
#define PASS true
#define FAIL false

// for Node functions
uint8_t DANGLING_NODE_NUM_TESTS = 6;
uint8_t NEXT_NODE_NUM_TESTS = 6;
uint8_t PREV_NODE_NUM_TESTS = 6;
uint8_t BETWEEN_NODE_NUM_TESTS = 3;
uint8_t SEARCH_FORWARD_NUM_TESTS = 4;

// for SinglyLinkedList functions
uint8_t CREATE_EMPTY_NUM_TESTS = 1;
uint8_t IS_EMPTY_NUM_TESTS = 3;
uint8_t SIZE_NUM_TESTS = 3;

/*** Node Unit Tests ***/

/** This documentation was generated by AI
 * @brief Tests the dangling_node function for proper node creation and initialization
 *
 * This function performs six tests on the dangling_node functionality:
 * 1. Verifies that a node created with value 0 correctly stores 0 as its data
 * 2. Verifies that a node created with value 0 has its next pointer set to NULL
 * 3. Verifies that a node created with a maximum positive value correctly stores that value
 * 4. Verifies that a node created with a positive value has its next pointer set to NULL
 * 5. Verifies that a node created with a minimum negative value correctly stores that value
 * 6. Verifies that a node created with a negative value has its next pointer set to NULL
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains DANGLING_NODE_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_dangling_node() {
    // heap allocated array to return test results
    bool* tests_status = (bool *) malloc(sizeof(bool) * DANGLING_NODE_NUM_TESTS);

    // Test 1: 0 is set properly for the Node
    Node* node = dangling_node(0);
    if (node->data == 0) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Test 2: Nodes with 0 as data have null next pointer
    if(node->next == NULL) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }
    free(node);

    // Test 3: positive numbers are set properly for the node
    node = dangling_node(INT64_MAX);
    if (node->data == INT64_MAX) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // Test 4: Nodes with positive data have NULL next pointers
    if (node->next == NULL) {
        tests_status[3] = PASS;
    } else {
        tests_status[3] = FAIL;
    }
    free(node);

    // Test 5: negative numbers are set properly for the node
    // this next test case was AI generated
    node = dangling_node(INT64_MIN);
    if (node->data == INT64_MIN) {
        tests_status[4] = PASS;
    } else {
        tests_status[4] = FAIL;
    }

    // Test 6: Nodes with negative data have NULL next pointers
    if (node->next == NULL) {
        tests_status[5] = PASS;
    } else {
        tests_status[5] = FAIL;
    }
    free(node);
    return tests_status;
}

/** This documentation was generated by AI.
* @brief Tests the next_node function for proper node creation and linking
*
* This function performs six tests on the next_node functionality:
* 1. Verifies that a node created with value 0 correctly stores 0 as its data
* 2. Verifies that the next pointer of the base node points to the newly created node
* 3. Verifies that a node created with a maximum positive value correctly stores that value
* 4. Verifies that the next pointer of the base node points to the newly created node with positive value
* 5. Verifies that a node created with a minimum negative value correctly stores that value
* 6. Verifies that the next pointer of the base node points to the newly created node with negative value
*
* @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
*         status of a test. The array contains NEXT_NODE_NUM_TESTS elements and must be freed by
*         the caller when no longer needed.
*/
bool* test_next_node() {
    // This whole function was AI generated using my work on the dangling_node unit test
    // function as context
    bool* tests_status = (bool *) malloc(sizeof(bool) * NEXT_NODE_NUM_TESTS);

    // Test 1: 0 is set properly for the Node
    Node* base = dangling_node(0);
    Node* node = next_node(0, base);
    if (node->data == 0) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Test 2: Next pointer points to the base node
    if(base->next == node) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }
    free(node);

    // Test 3: positive numbers are set properly for the node
    node = next_node(INT64_MAX, base);
    if (node->data == INT64_MAX) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // Test 4: Next pointer points to the base node
    if (base->next == node) {
        tests_status[3] = PASS;
    } else {
        tests_status[3] = FAIL;
    }
    free(node);

    // Test 5: negative numbers are set properly for the node
    node = next_node(INT64_MIN, base);
    if (node->data == INT64_MIN) {
        tests_status[4] = PASS;
    } else {
        tests_status[4] = FAIL;
    }

    // Test 6: Next pointer points to the base node
    if (base->next == node) {
        tests_status[5] = PASS;
    } else {
        tests_status[5] = FAIL;
    }
    free(node);
    free(base);
    return tests_status;
}

/** This documentation was generated by AI.
* @brief Tests the prev_node function for proper node creation and linking
*
* This function performs six tests on the prev_node functionality:
* 1. Verifies that a node created with value 0 correctly stores 0 as its data
* 2. Verifies that the next pointer of the base node points to the newly created node
* 3. Verifies that a node created with a maximum positive value correctly stores that value
* 4. Verifies that the next pointer of the base node points to the newly created node with positive value
* 5. Verifies that a node created with a minimum negative value correctly stores that value
* 6. Verifies that the next pointer of the base node points to the newly created node with negative value
*
* @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
*         status of a test. The array contains NEXT_NODE_NUM_TESTS elements and must be freed by
*         the caller when no longer needed.
*/
bool* test_prev_node() {
    // This whole function was AI generated using my work on the previous unit test
    // function as context
    bool* tests_status = (bool *) malloc(sizeof(bool) * PREV_NODE_NUM_TESTS);

    // Test 1: 0 is set properly for the Node
    Node* base = dangling_node(0);
    Node* node = prev_node(0, base);
    if (node->data == 0) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Test 2: Next pointer points to the base node
    if(node->next == base) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }
    free(node);

    // Test 3: positive numbers are set properly for the node
    node = prev_node(INT64_MAX, base);
    if (node->data == INT64_MAX) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // Test 4: Next pointer points to the base node
    if (node->next == base) {
        tests_status[3] = PASS;
    } else {
        tests_status[3] = FAIL;
    }
    free(node);

    // Test 5: negative numbers are set properly for the node
    node = prev_node(INT64_MIN, base);
    if (node->data == INT64_MIN) {
        tests_status[4] = PASS;
    } else {
        tests_status[4] = FAIL;
    }

    // Test 6: Next pointer points to the base node
    if (node->next == base) {
        tests_status[5] = PASS;
    } else {
        tests_status[5] = FAIL;
    }
    free(node);
    free(base);
    return tests_status;
}

/** This documentation was generated by AI.
 * @brief Tests the between_node function for proper node creation and linking between two existing nodes
 *
 * This function performs three tests on the between_node functionality:
 * 1. Verifies that a node created with value 12 correctly stores 12 as its data
 * 2. Verifies that the newly created node's next pointer correctly points to the next node
 * 3. Verifies that the previous node's next pointer correctly points to the newly created node
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains BETWEEN_NODE_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_between_node() {
    bool* tests_status = (bool *) malloc(sizeof(bool) * BETWEEN_NODE_NUM_TESTS);
    Node* prev = dangling_node(INT64_MIN);
    Node* next = dangling_node(INT64_MAX);

    Node* node = between_node(12, prev, next);
    // Test 1: data is set properly
    if (node->data == 12) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Test 2: inserted node's next pointer is set correctly
    if (node->next == next) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }

    // Test 3: prev node's next pointer is set correctly
    if (prev->next == node) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // free all the allocated data
    free(node);
    free(prev);
    free(next);

    return tests_status;
}

/** This documentation was generated by AI.
 * @brief Tests the search_forward function for finding data in a linked list
 *
 * This function performs four tests on the search_forward functionality:
 * 1. Verifies that the function correctly finds data located at the beginning of the chain
 * 2. Verifies that the function correctly finds data located in the middle of the chain
 * 3. Verifies that the function correctly finds data located at the end of the chain
 * 4. Verifies that the function correctly returns false when data is not present in the chain
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains SEARCH_FORWARD_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_search_forward() {
    bool* tests_status = (bool *) malloc(sizeof(bool) * SEARCH_FORWARD_NUM_TESTS);

    // create a chain of nodes
    Node* start = dangling_node(1);
    Node* middle = next_node(2, start);
    Node* end = next_node(3, middle);

    // Test 1: data is located at the beginning of the chain
    if(search_forward(start, 1)) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    // Tests 2 and 3 were generated by AI
    // Test 2: data is located in the middle of the chain
    if(search_forward(start, 2)) {
        tests_status[1] = PASS;
    } else {
        tests_status[1] = FAIL;
    }

    // Test 3: data is located at the end of the chain
    if(search_forward(start, 3)) {
        tests_status[2] = PASS;
    } else {
        tests_status[2] = FAIL;
    }

    // Test 4: data is not on the chain
    if (!(search_forward(start, 4))) {
        tests_status[3] = PASS;
    } else {
        tests_status[3] = FAIL;
    }

    free(start);
    free(middle);
    free(end);

    return tests_status;
}

/*** SinglyLinkedList Unit Tests ***/

/**
 * @brief Tests the create_empty function of the SinglyLinkedList implementation
 *
 * This function performs a test on the create_empty functionality:
 * 1. Verifies that a newly created linked list has its head node correctly set to NULL
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains CREATE_EMPTY_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_create_empty() {
    bool* tests_status = (bool *) malloc(sizeof(bool) * CREATE_EMPTY_NUM_TESTS);
    SinglyLinkedList* list_ptr = (SinglyLinkedList *) malloc(sizeof(SinglyLinkedList));

    // Test 1: head node is set to null
    if (list_ptr->head == NULL) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }

    free(list_ptr);

    return tests_status;
}

/** This documentation was written by AI
 * @brief Tests the is_empty function of the SinglyLinkedList implementation
 *
 * This function performs three tests on the is_empty functionality:
 * 1. Verifies that a newly created linked list is correctly identified as empty
 * 2. Verifies that a linked list with one element is correctly identified as not empty
 * 3. Verifies that a linked list with multiple elements is correctly identified as not empty
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains IS_EMPTY_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_is_empty() {
    // need heap allocated array to return each test fail (0) or pass (1)
    bool* tests_status = (bool *) malloc(sizeof(bool) * IS_EMPTY_NUM_TESTS);
    SinglyLinkedList* list_ptr = (SinglyLinkedList *) malloc(sizeof(SinglyLinkedList));
    // Test 1: a new singly linked list is empty
    if (is_empty(list_ptr)) {
        tests_status[0] = PASS;
    } else {
        tests_status[0] = FAIL;
    }
    // Test 2: a singly linked list with one element is not empty
    append_node(list_ptr, 12);
    if (is_empty(list_ptr)) {
        tests_status[1] = FAIL;
    } else {
        tests_status[1] = PASS;
    }
    // Test 3: a singly linked list with multiple elements is not empty
    // this one was autocompleted by an AI code generation
    append_node(list_ptr, 13);
    append_node(list_ptr, 14);
    if (is_empty(list_ptr)) {
        tests_status[2] = FAIL;
    } else {
        tests_status[2] = PASS;
    }
    free(list_ptr);
    return tests_status;
}

/**
 * @brief Tests the size function of the SinglyLinkedList implementation
 *
 * This function performs three tests on the size functionality:
 * 1. Verifies that an empty linked list correctly returns a size of 0
 * 2. Verifies that a linked list with one element correctly returns a size of 1
 * 3. Verifies that a linked list with multiple elements correctly returns the proper size
 *
 * @return bool* An array of boolean values where each element represents the pass (1) or fail (0)
 *         status of a test. The array contains SIZE_NUM_TESTS elements and must be freed by
 *         the caller when no longer needed.
 */
bool* test_size() {
    bool* tests_status = (bool *) malloc(sizeof(bool) * SIZE_NUM_TESTS);
    SinglyLinkedList* list_ptr = create_empty_list();

    // Test 1: empty list has size 0
    if(size(list_ptr) != 0) {
        tests_status[0] = FAIL;
    } else {
        tests_status[0] = PASS;
    }

    // Test 2: a list with one node has size 1
    append_node(list_ptr, 13);
    if(size(list_ptr) != 1) {
        tests_status[1] = FAIL;
    } else {
        tests_status[1] = PASS;
    }

    // Test 3: a list with more than one element has the correct size
    append_node(list_ptr, 14);
    if(size(list_ptr) != 2) {
        tests_status[2] = FAIL;
    } else {
        tests_status[2] = PASS;
    }

    return tests_status;
}

/*** Helper Functions */

/**
 * @brief Displays the results of unit test functions
 *
 * This function processes an array of test results and displays whether tests passed or failed.
 * It can show detailed results for each individual test when verbose mode is enabled,
 * and always displays a summary message indicating overall test success or failure.
 *
 * @param tests_status Pointer to a boolean array containing test results (PASS/FAIL)
 * @param num_tests The number of test results in the array
 * @param verbose If true, displays detailed results for each individual test
 */
void display_test_results(bool* tests_status, int8_t num_tests, bool verbose) {
    bool all_passed = true;
    for (int8_t i = 0; i < num_tests; i++) {
        if (tests_status[i] == PASS) {
            if (verbose) {
                printf("Test %d passed", i + 1);
            }
        } else {
            if (verbose) {
                printf("Test %d failed\n", i + 1);
            }
            all_passed = false;
        }
    }
    if (all_passed) {
        printf("All tests passed!\n");
    } else {
        printf("Some tests failed!\n");
    }
}

/*** Program Starting Point */

int main() {
    bool* tests_status = test_dangling_node();
    printf("Testing dangling_node function: ");
    display_test_results(tests_status, DANGLING_NODE_NUM_TESTS, false);
    free(tests_status);

    tests_status = test_next_node();
    printf("Testing next_node function: ");
    display_test_results(tests_status, NEXT_NODE_NUM_TESTS, false);
    free(tests_status);

    tests_status = test_prev_node();
    printf("Testing prev_node function: ");
    display_test_results(tests_status, PREV_NODE_NUM_TESTS, false);
    free(tests_status);

    tests_status = test_between_node();
    printf("Testing between_node function: ");
    display_test_results(tests_status, BETWEEN_NODE_NUM_TESTS, false);
    free(tests_status);

    tests_status = test_search_forward();
    printf("Testing search_forward function: ");
    display_test_results(tests_status, SEARCH_FORWARD_NUM_TESTS, false);
    free(tests_status);
    
    tests_status = test_create_empty();
    printf("Testing create_empty function: ");
    display_test_results(tests_status, CREATE_EMPTY_NUM_TESTS, false);
    free(tests_status);

    tests_status = test_is_empty();
    printf("Testing is_empty function: ");
    display_test_results(tests_status, IS_EMPTY_NUM_TESTS, false);
    free(tests_status);

    tests_status = test_size();
    printf("Testing size function: ");
    display_test_results(tests_status, SIZE_NUM_TESTS, false);
    free(tests_status);
}
